//Этот шейдер расставляет поданные позиции для травинок случайным образом

#pragma kernel CSMain

struct GeneratedVertex
{
    float3 positionOS;
    float3 normalOS;
    float2 uv;
};


float2 _patchSize;
uint2 _bladesAmount;
float _width;
float _height;
float _curvature;
float _maxBendAngleRad;
int _segmentCount;


RWStructuredBuffer<GeneratedVertex> _resVerts;
RWStructuredBuffer<int> _resIndices;

GeneratedVertex MakeGeneratedPoint(float3 pos, float3 normal, float2 uv)
{
    GeneratedVertex res = (GeneratedVertex) 0;
    res.positionOS = pos;
    res.normalOS = normal;
    res.uv = uv;
    return res;
}

//https://gist.github.com/keijiro/ee7bc388272548396870
float nrand(float2 uv)
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453);
}

float3 randomizeRotation(float3 pos, float3 center, float random)
{  
    float PI = 3.14159f;
    
    float angle = random * 2 * PI ;
    float3 res = float3(pos.x,pos.y,pos.z);
    
    res.x = cos(angle) * pos.x - sin(angle) * pos.z;
    res.z = sin(angle) * pos.x + cos(angle) * pos.z;
    
    return res;
}

//https://gist.github.com/keijiro/ee439d5e7388f3aafc5296005c8c3f33
// Rotation with angle (in radians) and axis
float3x3 AngleAxis3x3(float angle, float3 axis)
{
    float c, s;
    sincos(angle, s, c);

    float t = 1 - c;
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;

    return float3x3(
        t * x * x + c, t * x * y - s * z, t * x * z + s * y,
        t * x * y + s * z, t * y * y + c, t * y * z - s * x,
        t * x * z - s * y, t * y * z + s * x, t * z * z + c
    );
}

[numthreads(128,1,1)] //TODO? : Можно за-двумерить, добавить потоков в Y и использовать id.y
void CSMain (uint3 id : SV_DispatchThreadID)
{    
    uint totalAmount = _bladesAmount.x * _bladesAmount.y;
    if (id.x > totalAmount)
        return;
    
    uint indexX = id.x % _bladesAmount.x;
    uint indexY = floor(id.x / _bladesAmount.x);
    
    float2 step = float2(0,0);
    step.x = _patchSize.x / _bladesAmount.x;
    step.y = _patchSize.y / _bladesAmount.y;
    
    float3 res = float3(indexX * step.x, 0, indexY * step.y);
    
    float3 points[3];
    points[0] = float3(-_width/2, 0, 0);
    points[1] = float3(_width/2, 0, 0);
    points[2] = float3(0, _height, 0);
    
    //Изгиб верха, нужно его сделать перед поворотом всей травинки
    float bendAngle = nrand(indexX + indexY) * _maxBendAngleRad;
    float3x3 bendMatrix = AngleAxis3x3(bendAngle * pow(1, _curvature), float3(1, 0, 0));
    points[2] = mul(bendMatrix, points[2]);
    
    //Случайный поворот всей травинки
    float3 center = lerp(points[0], points[1], 0.5f); // Хотя можно и float3(0,0,0) поставить в лоб,
                                                      // так как в коде положение централизировано и локально.
                                                      // но так - гибче, в случае чего.
    points[0] = randomizeRotation(points[0], center, nrand(indexX + indexY));
    points[1] = randomizeRotation(points[1], center, nrand(indexX + indexY));
    
    //Случайное смещение
    GeneratedVertex vertices[3];
    float3 normal = cross(points[1] - points[0], points[2] - points[0]);
    
    float3 randPoint = float3((nrand(float2(id.x, id.x)) - step.x*2) % step.x,
                               0,
                              (nrand(float2(id.x, id.x) + step.x*step.y) - step.y*2) % step.y);
    
        //Композиция всех данных
    vertices[0] = MakeGeneratedPoint(randPoint + res + points[0], normal, float2(0, 0));
    vertices[1] = MakeGeneratedPoint(randPoint + res + points[1], normal, float2(1, 0));
    vertices[2] = MakeGeneratedPoint(randPoint + res + points[2], normal, float2(0.5, 1));
    
    int numGenVertices = 3;
    int numGenTriangles = 1;
    int numGenIndices = numGenTriangles * 3;
    int genIndexStart = id.x * numGenIndices;
    int genVertexStart = id.x * numGenVertices; //Номер травинки * 3.
    
    for (int i = 0; i < 3; i++)
    {
        _resVerts[genVertexStart + i] = vertices[i];
    }
    
    for (int j = 0; j < 3; j++)
    {
        _resIndices[genIndexStart + j] = genVertexStart + j;
    }
}

/*
float3 initialPointLeft = float3(-_width / 2, 0, 0);
    float3 initialPointRight = float3(_width / 2, 0, 0);
    
    float3 normal = cross(initialPointLeft - float3(0, 1, 0), initialPointRight - float3(0,1,0));
    
    float bendAngle = nrand(indexX + indexY) * _maxBendAngleRad;
    for (int i = 0; i < BLADE_SEGMENTS_AMOUNT; i++)
    {
        //Собираем UV
        float v = i / (float) BLADE_SEGMENTS_AMOUNT; // Высота, банально
        float u = 0.5f - (1 - v) * 0.5f; // Трава - симметрична по центру
        
        float3x3 bendMatrix = AngleAxis3x3(bendAngle * pow(abs(v), _curvature), float3(1, 0, 0));
        
        float3 upOffset = float3(0,lerp(0, _height, v),0);
        float3 genPointLeft = mul(bendAngle, upOffset + initialPointLeft + initialPosition + randPoint);
        float3 genPointRight = mul(bendAngle, upOffset + initialPointRight + initialPosition + randPoint);
        
        float3 center = lerp(genPointLeft, genPointRight, 0.5f);
        genPointLeft = randomizeRotation(genPointLeft, center, nrand(indexX + indexY + i));
        genPointRight = randomizeRotation(genPointRight, center, nrand(indexX + indexY + i));
        
        GeneratedVertex pointLeft = MakeGeneratedPoint(genPointLeft, normal ,float2(u, v));
        GeneratedVertex pointRight = MakeGeneratedPoint(genPointRight, normal ,float2(1 - u, v));
        
        vertices[i * 2] = pointLeft;
        vertices[i * 2 + 1] = pointRight;
    }    
    
    float3x3 bendMatrix = AngleAxis3x3(bendAngle * pow(1, _curvature), float3(1, 0, 0));
    vertices[BLADE_SEGMENTS_AMOUNT * 2] = MakeGeneratedPoint(mul(bendAngle, initialPosition + randPoint), normal, float2(0.5f,1));
    
    int numGenVertices = BLADE_SEGMENTS_AMOUNT * 2 + 1;
    int numGenTriangles = numGenVertices - 2;
    int numGenIndices = numGenTriangles * 3;
    int genIndexStart = id.x * numGenIndices;
    int genVertexStart = id.x * numGenVertices; //Номер травинки * 3.
    
    for (i = 0; i < numGenVertices; i++)
    {
        _resVerts[genVertexStart + i] = vertices[i];
    }
    
    for (int j = 0; j < numGenTriangles; j++)
    {
        int genTriangleIndexStart = genIndexStart + j * 3;
        for (int t = 0; t < 3; t++)
        {
            _resIndices[genIndexStart + t] = genVertexStart + j+t;
        }
    }
*/